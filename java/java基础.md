# java 基础 多线程 
## 1. 并行和并发有什么区别？
  * 并行是在不同实体上的多个事件，并发是在同一个实体上的多个事件。
  * 多以 并发编程的目标是充分利用处理器的每一个核，以达到最高的处理性能。  
## 2. 线程和进程的区别？
  * 进程是程序运行和资源分配的基本单位，一个程序至少有一个进程。一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多线程共享忍村资源，减少切换次数，从尔效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。统一进程中的多个线程之间可以并发执行。

## 多线程概念：
 * 线程池，对象等待池，对象锁池 ，synchronized ,锁的作用范围：synchronized修饰的方法、代码快、静态方法、类；不能修饰构造方法。

## 创建线程有哪几种方式？
  ### 1 继承Thread 类创建线程类
  ### 2 通过实现 Runnable接口创建线程
  ### 3 通过 callable 和future 创建线程

## 说说runnable 和callable有什么区别？
  * Runnable 接口中的run方法返回值是void,她做的事情只是纯粹的去执行run方法钟的代码而已。
  * Callable 接口中的cal方法是有返回值的，是一个泛型，和future，futrue task 配合可以用来获取异步执行的结果。

## 线程有哪些状态？
 * 创建状态。生成线程对象，并没有调用该对象的start方法，这时线程处于创建状态。
 * 就绪状态. 当调用了线程对象的start方法后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等单或者睡眠中回来之后，也会处于就绪状态。
 * 运行装填。 线程调度程序将处于就绪的线程设置为当前线程，此时线程就进入了运行状态，开始运行 run函数当中的代码。
 * 阻塞状态 线程正在运行的时候，被暂停，通常是为了等待，cpu事件片，之后在进行运行。sleep，susPENGD wait 方法都可以导致线程阻塞。
 * 死亡状态 如果一个线程的run方法执行结束或者调用stop 方法后，该线程就会死亡。对于已经死亡的线程，无法在使用start方法令其进入就绪。
## sleep（）和wait()有什么区别？
  * sleep() 方法是线程类 thread 的静态方法，让调用线程进入睡眠装填。让出执行机会给其他线程，等到休息时间结束后，线程进入就绪状态，和其他线程一起竞争cpu的执行时间。因为sleep 是静态放啊发，她不能改变对象的锁，当一个synchronized 块中调用了sleep方法，线程虽然进入休眠，但是对象的锁，没有被释放，其他对象依然无法访问这个对象。
  * wait() wait是object 类的方法。当一个线程只想到wait方法时，他就进入到一个和该对象相关的等待池，同时释放对象的锁，使其他线程能够访问，可以通过 notify ,notifyAll 方法来唤醒等待的线程。
## notify 和 notifyAll 有什么区别？
  * 如果线程调用了对象的wait方法，那么线程会处在该对象的等待池中，等待池中的线程不会去竞争该对象的锁
  * 当有线程调用了对象的 notifyAll 方法或notify方法，被唤醒的线程会进入该对象的锁池中，所持中的线程会竞争该对象锁。也就是说，调用了notify方法只要一个线程会有等待池进入锁池，而notifyALL 会将该对象等待池内所有的下称移动到锁池中，等待锁竞争。
  * 优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用wait方法，它才会重新回到等待池中。而竞争到对象锁得线程则继续往下执行，直到执行完了synchronized代码快，它会释放调该对象锁，这是锁池中的线程会继续竞争该对象锁。
## run() 和 start（） 有什么区别？
  * 每个线程都是通过某个特定的THread对象所对应的run方法来完成其操作的，方法RUN称为线程体。通过调用thread类的start()方法来启动一个线程。
  * start() 方法来启动一个线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；此时此线程是处于就绪状态，并没有运行，然后哦通过此类thread 类调用run方法来完成其运行装态。这里run方法称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程终止，然后cpu再调用其他线程
 * run方法实在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用run（），其实就相当调用了一个普通的函数而已。直接调用run方法必须等待run方法执行完毕后，才会执行下面的代码吗，所以执行路径还是一条，根本没有线程特征，所以在多线程执行时要使用start方法而不是run方法。

 ## 创建线程池有哪几种方式？ （4种）
 * newFixedThreadPool( int nthreads)
   创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池最大数量，这个线程池规模不在变化，当线程发生未预期错误时，线程池会补充一个新的线程。
 * newCachedThreadPool() 
   创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程，而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。
 * newSingleThreadExecutor()
   这是一个单线程的Executor,它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的代替它;他的特点是能确保依照任务在队列中的顺序来串序执行。
 * newScheduledThreadPool(int corePoolSize)
   创建一个固定长度的线程池，而且以延迟或者定时来执行任务，类似与Timer

 ## 线程池中 submit 和 execute 方法有什么区别？

 * 接受的参数不一样
 * submit 有返回值 ，而execute没有
 * submit 方便Exception 处理。

 ## 在java 程序中怎么保证多线程的运行安全？
 * 原子性 提供互斥访问。同一时刻只能有一个线程对数据进行操作（atomic,synchronized）;
 * 可见性 一个线程对主内存的修改可以及时被其他线程看到 （synchronized,volatile）;
 * 有序性 一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）        

 ## 多线程锁升级原理是什么？

 * 在java中，锁共有四种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁，和重量级锁，这几个状态会随着竞争情况逐渐升级。锁可以升级，但不能降级。

 ## 什么是死锁？
 * 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞现象，若无外力作用下，他们都将无法推进下去。此时系统处于死锁状态或者系统产生了死锁，这些永远在互相等待的进程称为死锁进程，是操作系统曾main的一个错误，是进程死锁的简称。

 ## 怎么防止死锁？

 * 互斥条件
 * 请求和保持条件
 * 不可剥夺条件
 * 环路等待条件

 ## ThreadLoacl是什么？有哪些使用场景？
 * 线程局部变量是局限与线程内部的变量，属于线程自身所有，不在多个线程间共享。java 提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如web服务器）使用线程局部变量的时候要特别的小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一但在工作完成后没有释放，java应用就会存在内存泄漏的风险。

 ## 说一下synchronized 底层实现原理？
 * synchronized 可以保证方法或者代码快在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性，</br>
 java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</br>
 * 普通同步方法,锁时当前实例对象
 * 静态同步方法，锁时当前类的class对象
 * 同步方法快 锁时括号里面的对象

 ## synchronized 和volatile的区别时什么？
 * volatile仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。
 * volatile 仅能实现变量的修改可见性，不能保证原子性；而synchronized 则可以保证变量修改的可见性和原子性
 * volatile 不能造成线程的阻塞；synchronized 可能会造成线程的阻塞
 * valatile 标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。
 ## synchronized 和Lock有什么区别？
 * 首先synchronized 是java 内置关键字，在jvm层面，LOck是个Java类；
 * synchronized 无法判断是否获取锁的装填，lock可以判断时候获取到锁
 * synchronized 会自动释放锁，Lock需要在finally中手工释放锁（unlock方法释放锁），否则会造成死锁。
 * 用synchronized 关键字的线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2就会一直等待下去，而Lock锁就不一定会等待下去，如果常识获取不到锁，线程可以不用一直等待就结束了
 * synchronized 的锁可重入，不可中断、非公平，而Lock锁可重入、可中断,可公平、或不公平
  * Lock锁适合大量同步的代码同步问题，synchronized 锁适合代码量少的同步问题。